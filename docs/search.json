[
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "Bienvenue sur mon blog ! Ici, je partage mes réflexions et mes expériences sur divers sujets. Je publie régulièrement (c’est faux) des articles sur la météo (encore un mensonge), et j’espère que vous trouverez mes billets intéressants et utiles. N’hésitez pas à laisser des commentaires et à partager vos propres expériences. Je suis toujours ravi de discuter avec mes (nombreux) lecteurs !"
  },
  {
    "objectID": "posts/exercice_3/index.html",
    "href": "posts/exercice_3/index.html",
    "title": "Exercice 3",
    "section": "",
    "text": "Listez les fichiers présents dans le dossier data. Quelles sont les extensions des différents fichiers ?\n\n\nlist.files(\"data/\")\n\ncharacter(0)\n\n\n.sqlite .json .parquet\n\nLisez le fichier .parquet en utilisant la librairie arrow. Quelles sont les dimensions de la table ? Quelles sont les colonnes présentes ?\n\n\nlibrary(arrow)\n\n\nAttachement du package : 'arrow'\n\n\nL'objet suivant est masqué depuis 'package:utils':\n\n    timestamp\n\ntokyo = read_parquet(\"~/M1/S2/R avancé/my_blog/data/tokyo_athletes.parquet\")\nstr(tokyo)\n\nClasses 'tbl_df', 'tbl' and 'data.frame':   11085 obs. of  3 variables:\n $ Name      : chr  \"AALERUD Katrine\" \"ABAD Nestor\" \"ABAGNALE Giovanni\" \"ABALDE Alberto\" ...\n $ NOC       : chr  \"Norway\" \"Spain\" \"Italy\" \"Spain\" ...\n $ Discipline: chr  \"Cycling Road\" \"Artistic Gymnastics\" \"Rowing\" \"Basketball\" ...\n\n\n\nLisez le fichier .json en utilisant la librairie jsonlite. Quelles sont les dimensions de la table ? Quelles sont les colonnes présentes ?\n\n\nlibrary(jsonlite)\n\nWarning: le package 'jsonlite' a été compilé avec la version R 4.3.2\n\nolympics = read_json(\"~/M1/S2/R avancé/my_blog/data/olympics_athletes.json\")\nlength(olympics)\n\n[1] 269731\n\n\nC’est une liste qui contient 269731 listes. Comme le montre cet exemple :\n\nolympics[1]\n\n[[1]]\n[[1]]$ID\n[1] 1\n\n[[1]]$Name\n[1] \"A Dijiang\"\n\n[[1]]$Sex\n[1] \"M\"\n\n[[1]]$Age\n[1] 24\n\n[[1]]$Height\n[1] 180\n\n[[1]]$Weight\n[1] 80\n\n[[1]]$Team\n[1] \"China\"\n\n[[1]]$NOC\n[1] \"CHN\"\n\n[[1]]$Games\n[1] \"1992 Summer\"\n\n[[1]]$City\n[1] \"Barcelona\"\n\n[[1]]$Sport\n[1] \"Basketball\"\n\n[[1]]$Event\n[1] \"Basketball Men's Basketball\"\n\n\nChaque liste contient des données propres à un athlète. Donc on a des infos (ID, nom, …) sur 269731 athlètes.\nOn va le convertir en df pour la suite :\n\nolymp = fromJSON(\"~/M1/S2/R avancé/my_blog/data/olympics_athletes.json\")\nstr(olymp)\n\n'data.frame':   269731 obs. of  13 variables:\n $ ID    : int  1 2 3 4 5 5 5 5 5 5 ...\n $ Name  : chr  \"A Dijiang\" \"A Lamusi\" \"Gunnar Nielsen Aaby\" \"Edgar Lindenau Aabye\" ...\n $ Sex   : chr  \"M\" \"M\" \"M\" \"M\" ...\n $ Age   : int  24 23 24 34 21 21 25 25 27 27 ...\n $ Height: int  180 170 NA NA 185 185 185 185 185 185 ...\n $ Weight: num  80 60 NA NA 82 82 82 82 82 82 ...\n $ Team  : chr  \"China\" \"China\" \"Denmark\" \"Denmark/Sweden\" ...\n $ NOC   : chr  \"CHN\" \"CHN\" \"DEN\" \"DEN\" ...\n $ Games : chr  \"1992 Summer\" \"2012 Summer\" \"1920 Summer\" \"1900 Summer\" ...\n $ City  : chr  \"Barcelona\" \"London\" \"Antwerpen\" \"Paris\" ...\n $ Sport : chr  \"Basketball\" \"Judo\" \"Football\" \"Tug-Of-War\" ...\n $ Event : chr  \"Basketball Men's Basketball\" \"Judo Men's Extra-Lightweight\" \"Football Men's Football\" \"Tug-Of-War Men's Tug-Of-War\" ...\n $ Medal : chr  NA NA NA \"Gold\" ...\n\n\n\nImportez la librairie RSQLite, et ouvrez une connexion à la base de données sqlite en utilisant la fonction dbConnect. Le driver à utiliser sera SQLite(). Quelles sont les tables présentes dans la table ? Vous pourrez utiliser la fonction dbListTables.\n\n\nlibrary(RSQLite)\ncon &lt;- dbConnect(SQLite(), dbname = \"~/M1/S2/R avancé/my_blog/data/data.sqlite\")\ndbListTables(con)\n\n[1] \"mtcars\"            \"olympics_athletes\" \"tokyo_athletes\"   \n[4] \"tokyo_medals\"      \"tokyo_teams\"      \n\n\n\nCréez deux nouvelles tables dans la base de données à l’aide de la fonction dbWriteTable. Les tables s’appeleront respectivement olympics_athletes et tokyo_athletes pour les fichiers olympics_athletes.json et tokyo_athletes.parquet.\n\nJe me suis rendu compte que dbWriteTable ne prend que des data.frame en “value”. Donc j’ai fait quelques transformations de class pour pouvoir insérer les 2 tables (je l’ai déjà fait plus haut pour le JSON).\n\ntokyo_df &lt;- as.data.frame(tokyo)\nstr(tokyo_df)\n\n'data.frame':   11085 obs. of  3 variables:\n $ Name      : chr  \"AALERUD Katrine\" \"ABAD Nestor\" \"ABAGNALE Giovanni\" \"ABALDE Alberto\" ...\n $ NOC       : chr  \"Norway\" \"Spain\" \"Italy\" \"Spain\" ...\n $ Discipline: chr  \"Cycling Road\" \"Artistic Gymnastics\" \"Rowing\" \"Basketball\" ...\n\n# comme je l'ai déjà fait je mets les commandes en commentaire\n# dbWriteTable(con,\"tokyo_athletes\", tokyo_df)\n# dbWriteTable(con,\"olympics_athletes\", olymp)\n\n\nInspectez la table olympics_athletes en utilisant la fonction dbListFields. Quelles sont les colonnes de la table ?\n\n\ndbListFields(con,\"olympics_athletes\")\n\n [1] \"ID\"     \"Name\"   \"Sex\"    \"Age\"    \"Height\" \"Weight\" \"Team\"   \"NOC\"   \n [9] \"Games\"  \"City\"   \"Sport\"  \"Event\"  \"Medal\" \n\n\n\nImportez cette table depuis la base de données en utilisant la fonction dbReadTable. Convertissez la table en tibble en utilisant la fonction as_tibble.\n\n\nlibrary(tibble)\nolympiii = dbReadTable(con,\"olympics_athletes\")\nolympiii_tibble = as_tibble(olympiii)\nclass(olympiii_tibble)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\nConvertissez la colonne Sex en variable catégorielle avec la fonction mutate.\n\n\nlibrary(dplyr)\n\n\nAttachement du package : 'dplyr'\n\n\nLes objets suivants sont masqués depuis 'package:stats':\n\n    filter, lag\n\n\nLes objets suivants sont masqués depuis 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(tidyr)\n\nolympiii_tibble = olympiii_tibble %&gt;%\n  mutate(Sex = factor(Sex))\n\nclass(olympiii_tibble$Sex)\n\n[1] \"factor\"\n\n\n\nCréez deux colonnes à partir de la colonne Games. La première colonne Year sera une colonne de type integer contenant l’année des jeux. La deuxième colonne isSummer sera une colonne booléenne qui indiquera si les jeux sont des jeux d’été ou d’hiver. Vous pourrez utiliser la fonction separate_wider_delim de tidyr notamment. Les questions suivantes nécessitent l’application de plusieurs instructions en séquence. Essayez tant que possible de chaîner les instructions avec des pipes (%&gt;% ou |&gt;).\n\n\nolympiii_tibble &lt;- olympiii_tibble |&gt;\n  separate_wider_delim(Games,\n    names = c(\"Year\", \"isSummer\"),\n    delim = \" \"\n  ) |&gt;\n  mutate(\n    Year = as.integer(Year),\n    isSummer = if_else(isSummer == \"Summer\", TRUE, FALSE)\n  )\n\nstr(olympiii_tibble)\n\ntibble [269,731 × 14] (S3: tbl_df/tbl/data.frame)\n $ ID      : int [1:269731] 1 2 3 4 5 5 5 5 5 5 ...\n $ Name    : chr [1:269731] \"A Dijiang\" \"A Lamusi\" \"Gunnar Nielsen Aaby\" \"Edgar Lindenau Aabye\" ...\n $ Sex     : Factor w/ 2 levels \"F\",\"M\": 2 2 2 2 1 1 1 1 1 1 ...\n $ Age     : int [1:269731] 24 23 24 34 21 21 25 25 27 27 ...\n $ Height  : int [1:269731] 180 170 NA NA 185 185 185 185 185 185 ...\n $ Weight  : num [1:269731] 80 60 NA NA 82 82 82 82 82 82 ...\n $ Team    : chr [1:269731] \"China\" \"China\" \"Denmark\" \"Denmark/Sweden\" ...\n $ NOC     : chr [1:269731] \"CHN\" \"CHN\" \"DEN\" \"DEN\" ...\n $ Year    : int [1:269731] 1992 2012 1920 1900 1988 1988 1992 1992 1994 1994 ...\n $ isSummer: logi [1:269731] TRUE TRUE TRUE TRUE FALSE FALSE ...\n $ City    : chr [1:269731] \"Barcelona\" \"London\" \"Antwerpen\" \"Paris\" ...\n $ Sport   : chr [1:269731] \"Basketball\" \"Judo\" \"Football\" \"Tug-Of-War\" ...\n $ Event   : chr [1:269731] \"Basketball Men's Basketball\" \"Judo Men's Extra-Lightweight\" \"Football Men's Football\" \"Tug-Of-War Men's Tug-Of-War\" ...\n $ Medal   : chr [1:269731] NA NA NA \"Gold\" ...\n\n\n\nCalculez la moyenne d’age des athletes pour chacune des éditions des JO d’été. Quelle édition a compté les athlètes les plus jeunes ? Les plus vieux ?\n\nPour les plus jeunes :\n\nmean_age_by_year &lt;- olympiii_tibble |&gt;\n  group_by(Year) |&gt; \n  summarize(mean_age = mean(Age, na.rm = TRUE)) |&gt; \n  arrange(mean_age)\nhead(mean_age_by_year,1)\n\n# A tibble: 1 × 2\n   Year mean_age\n  &lt;int&gt;    &lt;dbl&gt;\n1  1896     23.6\n\n\nPour les plus vieux :\n\nmean_age_by_year |&gt; \n  arrange(desc(mean_age)) |&gt; \n  head(1)\n\n# A tibble: 1 × 2\n   Year mean_age\n  &lt;int&gt;    &lt;dbl&gt;\n1  1932     29.6\n\n\n\nQuelle est la discipline des JO d’été dont la taille des athlètes féminines est la plus grande ?\n\n\nfemale_athletes &lt;- olympiii_tibble %&gt;%\n  filter(Sex == \"F\",isSummer == TRUE) |&gt; \n  arrange(desc(Height))\n\nhead(female_athletes$Sport,1)\n\n[1] \"Basketball\"\n\n\nQuelle a été cette discipline au cours de chacune des éditions ?\n\nlargest_height_by_year &lt;- female_athletes %&gt;%\n  group_by(Year) %&gt;%\n  top_n(1, Height) %&gt;%\n  select(Year, Sport, Height, Name)\nlargest_height_by_year\n\n# A tibble: 37 × 4\n# Groups:   Year [23]\n    Year Sport      Height Name                                       \n   &lt;int&gt; &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;                                      \n 1  2000 Basketball    213 \"Magorzata Teresa \\\"Margo\\\" Dydek (-Twigg)\"\n 2  1976 Basketball    210 \"Ujana Semjonova\"                          \n 3  1980 Basketball    210 \"Ujana Semjonova\"                          \n 4  2012 Basketball    206 \"Wei Wei\"                                  \n 5  1984 Basketball    205 \"Chen Yuefang\"                             \n 6  1984 Basketball    205 \"Susanna \\\"Sue\\\" Geh\"                      \n 7  1988 Basketball    204 \"Zheng Haixia\"                             \n 8  1992 Basketball    204 \"Zheng Haixia\"                             \n 9  1996 Basketball    204 \"Zheng Haixia\"                             \n10  2016 Basketball    203 \"Elizabeth Folake \\\"Liz\\\" Cambage\"         \n# ℹ 27 more rows\n\n\nCalculez le nombre de fois où chaque discipline a été la discipline avec les plus grandes athlètes.\n\nlargest_height_by_year %&gt;%\n  count(Sport)\n\n# A tibble: 27 × 3\n# Groups:   Year [23]\n    Year Sport         n\n   &lt;int&gt; &lt;chr&gt;     &lt;int&gt;\n 1  1920 Diving        1\n 2  1924 Fencing       1\n 3  1924 Tennis        1\n 4  1928 Fencing       1\n 5  1932 Fencing       1\n 6  1936 Fencing       1\n 7  1948 Athletics     3\n 8  1952 Athletics     3\n 9  1956 Athletics     1\n10  1960 Swimming      2\n# ℹ 17 more rows\n\n\nVous disposez du texte suivant :\n\ntexte = \"Les jeux olympiques d’été se déroulent normalement tous les 4 ans, durant les mois de Juillet et Août. Les jeux de Rio ont eu lieu du 5 Août 2016 au 20 Août 2016,\nceux de Tokyo du 23 Juillet 2021 au 8 Août 2021, et ceux de Paris auront lieu du\n26 Juillet 2024 au 11 Août 2024. Plus de 10000 athlètes sont attendus du monde\nentier à Paris.\"\n\n\nEn utilisant les fonctions du packages stringr, extrayez les dates des différentes éditions des JO. Aide : définissez une expression régulière capable de capturer une séquence de caractères représentant une date telle que “26 Juillet 2024”. Vous pourrez utiliser cette regex avec la fonction str_extract_all par exemple.\n\n\nlibrary(stringr)\n\nWarning: le package 'stringr' a été compilé avec la version R 4.3.2\n\ndate = str_extract_all(texte, \"\\\\b\\\\d{1,2}\\\\s(?:Janvier|Février|Mars|Avril|Mai|Juin|Juillet|Août|Septembre|Octobre|Novembre|Décembre)\\\\s\\\\d{4}\\\\b\")\ndate\n\n[[1]]\n[1] \"5 Août 2016\"     \"20 Août 2016\"    \"23 Juillet 2021\" \"8 Août 2021\"    \n[5] \"26 Juillet 2024\" \"11 Août 2024\"   \n\n\n\nRemplacez les noms des mois par leur numéro pour rendre ces éléments convertibles en date en utilisant la fonction str_replace.\n\n\ntexte_avant_date = str_replace_all(date[[1]],\n  c(\"Juillet\" = \"07\", \"Août\" = \"08\")\n)\ntexte_avant_date\n\n[1] \"5 08 2016\"  \"20 08 2016\" \"23 07 2021\" \"8 08 2021\"  \"26 07 2024\"\n[6] \"11 08 2024\"\n\n\n\nConvertissez ces 3 éléments en date en utilisant la fonction appropriée du package lubridate.\n\n\nlibrary(lubridate)\n\n\nAttachement du package : 'lubridate'\n\n\nL'objet suivant est masqué depuis 'package:arrow':\n\n    duration\n\n\nLes objets suivants sont masqués depuis 'package:base':\n\n    date, intersect, setdiff, union\n\ntexte_modifie &lt;- gsub(\"\\\\b(\\\\d{1,2}) (\\\\d{2}) (\\\\d{4})\\\\b\", \"\\\\1-\\\\2-\\\\3\", texte_avant_date)\ndate_final = dmy(texte_modifie)\nclass(date_final)\n\n[1] \"Date\"\n\n\n\nCombien de jours ont séparés les éditions de Rio et Tokyo ? Et sépareront les éditions de Tokyo et de Paris ? Faites le même calcul en semaines.\n\n\nRio_Tokyo = interval(start = \"2016-08-20\", end = \"2021-07-23\")\nas.numeric(Rio_Tokyo, \"days\")\n\n[1] 1798\n\nas.numeric(Rio_Tokyo, \"week\")\n\n[1] 256.8571\n\n\n\nTokyo_Paris = interval(start = \"2021-08-08\", end = \"2024-07-26\")\nas.numeric(Tokyo_Paris, \"days\")\n\n[1] 1083\n\nas.numeric(Tokyo_Paris, \"week\")\n\n[1] 154.7143"
  },
  {
    "objectID": "posts/exercice_1/index.html",
    "href": "posts/exercice_1/index.html",
    "title": "Exercice 1",
    "section": "",
    "text": "importation :\n\npath = (\"~/M1/S2/R avancé/my_blog/data/paris-2024-sites-olympiques-et-paralympiques-franciliens.csv\")\ndata_ex = read.table(path, header = TRUE, sep = \";\", quote = \"\\\"\")\n\n\nCréez un script .R intitulé exercice.R.\n\nDésolé mais les quartos c’est mieux. Il faudrait faire ça : usethis::use_r(“exercice”)\n\nLisez le fichier exo_1_ex.txt avec la fonction read.table. Le résultat sera affecté à l’objet de nom data_ex. Le jeux de données contient 4 colonnes. Quels sont les noms et la nature des colonnes ? Combien de lignes contient la data.frame ?\n\n\nstr(data_ex)\n\n'data.frame':   31 obs. of  4 variables:\n $ geo_point                     : chr  \"48.841319, 2.253076\" \"48.924388, 2.359871\" \"48.751095, 2.0759\" \"48.788046, 2.034987\" ...\n $ nom                           : chr  \"Parc des Princes\" \"Stade de France\" \"Golf national\" \"Vélodrome National de Saint-Quentin-en-Yvelines\" ...\n $ sites_olympiques_paralympiques: chr  \"Site olympique\" \"Site olympique,Site paralympique\" \"Site olympique\" \"Site olympique,Site paralympique\" ...\n $ sports                        : chr  \"Football\" \"Athlétisme,Para athlétisme,Rugby\" \"Golf\" \"Cyclisme sur piste,Para cyclisme sur piste\" ...\n\n\n31 obs\n\nCombien y a t’il de sites olympiques ?\n\n\nsum(grepl(\"Site olympique\", data_ex$sites_olympiques_paralympiques, ignore.case = TRUE))\n\n[1] 26\n\n\n26 olympiques\n\nCombien y a t’il de sites paralympiques ?\n\n\nsum(grepl(\"Site paralympique\", data_ex$sites_olympiques_paralympiques, ignore.case = TRUE))\n\n[1] 19\n\n\n19 paralympiques\n\nQuels sont les sites qui accueillent plusieurs disciplines sportives ?\n\nj’ai juste compté les lignes qui présentent au moins une virgule dans la colonne “sports” :\n\nlibrary(stringr)\n\nWarning: le package 'stringr' a été compilé avec la version R 4.3.2\n\nsites_multisports = subset(data_ex, str_count(sports, \",\") &gt; 0)\nsites_multisports$nom\n\n [1] \"Stade de France\"                                \n [2] \"Vélodrome National de Saint-Quentin-en-Yvelines\"\n [3] \"Stade Roland Garros\"                            \n [4] \"Arena Paris Sud 4 (Porte de Versailles)\"        \n [5] \"Pont d'Iéna\"                                    \n [6] \"Arena Bercy\"                                    \n [7] \"Arena Paris nord\"                               \n [8] \"Arena Paris Sud 6 (Porte de Versailles)\"        \n [9] \"Stade de la Concorde\"                           \n[10] \"Arena Champs de Mars\"                           \n[11] \"La Défense Arena\"                               \n[12] \"Stade nautique\"                                 \n[13] \"Arena Paris Sud 1 (Porte de Versailles)\"        \n[14] \"Stade Tour Eiffel\"                              \n[15] \"Arena La Chapelle\"                              \n[16] \"Centre aquatique\"                               \n[17] \"Château de Versailles\"                          \n[18] \"Grand Palais\"                                   \n[19] \"Invalides\"                                      \n\n\n\nQuels sont les disciplines para-olympiques accueillies dans ces sites franciliens ?\n\nDonc parmi les 19 sites qui accueillent plusieurs disciplines, il faut trouver celles qui sont para-olympiques.\nJe suis allé chercher la liste sur https://www.paris2024.org/fr/sports-paralympiques/\nOn obtient ça : Basket fauteuil, boccia, cécifoot, escrime fauteuil goalball, para athlétisme, para aviron, para badminton, para canoë, para cyclisme sur route, para cyclisme sur piste, para équitation (dressage), para haltérophilie, para judo, para natation, para taekwondo, para tennis de table, para tir à l’arc, para tir sportif, para triathlon, rugby fauteuil, tennis fauteuil, volleyball assis\nPour que ça soit plus léger dans le code j’ai utilisé des mots clés tels que para, fauteuil ou assis. Puis j’ai écris les derniers en entier (ceux surlignés).\n\nsites_para_olympiques &lt;- subset(\n  sites_multisports,\n  grepl(\"fauteuil|Para|assis|Goalball|Cécifoot\", sports, ignore.case = TRUE)\n)\n\n\nQuel(s) site(s) accueille(nt) le plus de disciplines différentes ?\n\nComme dans chaque site les disciplines sont tout le temps différentes, on peut se contenter de compter le(s) site(s) avec le plus de virgules. (ou alors j’ai mal compris la question)\n\nnb_disciplines &lt;- str_count(data_ex$sports, \",\")\n\n# nombre de virgule maximum dans un site\nmax_nb_virgules &lt;- max(nb_disciplines)\n\n# tous les sites avec l'indice maximum de virgules\nindices_max &lt;- which(nb_disciplines == max_nb_virgules)\n\n# affichage de leur nom\ndata_ex$nom[indices_max]\n\n[1] \"Arena Bercy\"          \"Arena Paris nord\"     \"Stade de la Concorde\"\n[4] \"Arena Champs de Mars\" \"Stade nautique\"       \"Arena La Chapelle\"   \n[7] \"Grand Palais\"         \"Invalides\"           \n\n\n\nQuelle discipline aura lieu sur le plus grand nombre de sites ? Quels sont ces sites ?\n\nDans un premier temps, il faut découper correctement les disciplines pour ensuite les compter :\n\nsports_separes &lt;- unlist(strsplit(data_ex$sports, \",\"))\ncomptage_disciplines &lt;- table(sports_separes)\n\nMaintenant, on peut identifier la ou les discipline(s) apparue(s) un maximum :\n\nindices2_max &lt;- which(comptage_disciplines == max(comptage_disciplines))\nnames(comptage_disciplines[indices2_max])\n\n[1] \"Athlétisme\"\n\n\nPour finir, on affiche les noms des sites qui présentent la discipline “Athlétisme” :\n\nsites_athletisme &lt;- grep(\"Athlétisme\", data_ex$sports)\ndata_ex$nom[sites_athletisme]\n\n[1] \"Stade de France\"         \"Hôtel de ville de Paris\"\n[3] \"Pont d'Iéna\"             \"Invalides\"              \n\n\n\nA vol d’oiseau, quels sont les sites les deux sites les plus proches ?\n\nDans un premier temps, il faut que les coordonnées soient fournies sous forme de vecteur numérique avec deux éléments (la latitude et la longitude) pour que distHaversine fonctionne. Petit exemple avec les 2 premières lignes du dataset :\n\nlibrary(geosphere)\n\nexemple = data_ex$geo_point[[1]]\nex2 = data_ex$geo_point[[2]]\n\nla = as.numeric(unlist(strsplit(exemple, \",\")))\nla2 = as.numeric(unlist(strsplit(ex2, \",\")))\n\ndistHaversine(la, la2)\n\n[1] 15056.74\n\n\nOn va se faire une petite fonction qui fait ça pour nous quand on rentre juste data_ex$geo_point[[1]] (par exemple) en paramètre :\n\ndistance_entre_points &lt;- function(coord1, coord2) {\n  coord1 &lt;- as.numeric(strsplit(coord1, \",\")[[1]])\n  coord2 &lt;- as.numeric(strsplit(coord2, \",\")[[1]])\n  distHaversine(coord1, coord2)\n}\n# exemple d'utilisation :\ndistance_entre_points(data_ex$geo_point[[3]],data_ex$geo_point[[4]])\n\n[1] 6135.202\n\n\nMaintenant l’idée c’est de calculer automatiquement le distance entre tous les sites du dataset à l’aide d’une boucle. On stocke les résultats de cette boucle dans une matrice “distances” :\n\ndistances &lt;- matrix(NA, nrow = nrow(data_ex), ncol = nrow(data_ex))\nfor (i in 1:nrow(data_ex)) {\n  for (j in 1:nrow(data_ex)) {\n    distances[i, j] &lt;- distance_entre_points(data_ex[i, \"geo_point\"], data_ex[j, \"geo_point\"])\n  }\n}\n\n# On fait juste gaffe à virer les distances d'un site à lui même\ndiag(distances) &lt;- NA\n\nMaintenant on peut répondre à la question :\n\ndist_min &lt;- which(distances == min(distances, na.rm = TRUE), arr.ind = TRUE)\n\ndata_ex$nom[dist_min[,1]]\n\n[1] \"Stade BMX de Saint-Quentin-en-Yvelines\"         \n[2] \"Vélodrome National de Saint-Quentin-en-Yvelines\"\n\n\nbonus si on veut savoir la distance :\n\n# on cherche la ligne des 2 sites :\nwhich(data_ex$nom == \"Stade BMX de Saint-Quentin-en-Yvelines\")\n\n[1] 20\n\nwhich(data_ex$nom == \"Vélodrome National de Saint-Quentin-en-Yvelines\")\n\n[1] 4\n\n# on utilise notre fonction :\ndistance_entre_points(data_ex$geo_point[[20]],data_ex$geo_point[[4]])\n\n[1] 91.69166\n\n\n\nQuels sont les deux sites les plus éloignés ?\n\nPlus qu’à faire l’inverse d’avant :\n\ndist_max &lt;- which(distances == max(distances, na.rm = TRUE), arr.ind = TRUE)\n\ndata_ex$nom[dist_max[,1]]\n\n[1] \"Colline d'Elancourt\" \"Stade nautique\"     \n\n\nbonus si on veut savoir la distance :\n\n# on cherche la ligne des 2 sites :\nwhich(data_ex$nom == \"Colline d'Elancourt\")\n\n[1] 28\n\nwhich(data_ex$nom == \"Stade nautique\")\n\n[1] 17\n\n# on utilise notre fonction :\ndistance_entre_points(data_ex$geo_point[[28]],data_ex$geo_point[[17]])\n\n[1] 74882.55\n\n\n\nVous êtes un heureux millionaire et souhaitez investir dans un bien immobilier. Vous décidez d’acheter un appartement situé au barycentre de l’ensemble des sites olympiques. Où se situe cet appartement ?\n\nComment calculer un barycentre pour les nuls (pour moi en somme) :\nEn pratique, cela signifie que nous additionnons toutes les latitudes et toutes les longitudes de tous les sites, puis nous divisons par le nombre total de sites pour trouver les coordonnées moyennes, qui représentent le barycentre de tous les sites.\nok ça part :\n\n# on fait une matrice avec les coord exploitables\ncoordonnees &lt;- sapply(data_ex$geo_point, function(x) as.numeric(strsplit(x, \",\")[[1]]))\n# puis on fait la moyenne de lat et long de cette matrice :\nc(mean(coordonnees[1, ]), mean(coordonnees[2, ]))\n\n[1] 48.86684  2.29757\n\n\nMaintenant on va utiliser reverse_geocode pour identifier le nom d’une adresse à partir d’une localisation :\n\nlibrary(tidygeocoder)\nlibrary(tibble)\nlibrary(dplyr, warn.conflicts = FALSE)\n\ntibble(\n    latitude = c(48.8668),\n    longitude = c(2.29757)\n  ) %&gt;%\n  reverse_geocode(\n    lat = latitude,\n    long = longitude,\n    method = 'osm',\n    full_results = TRUE\n  )%&gt;%\n  select(address)\n\nPassing 1 coordinate to the Nominatim single coordinate geocoder\n\n\nQuery completed in: 1 seconds\n\n\n# A tibble: 1 × 1\n  address                                                                       \n  &lt;chr&gt;                                                                         \n1 23, Avenue Pierre 1er de Serbie, Quartier de Chaillot, Paris 16e Arrondisseme…\n\n\nj’ai clairement copié collé l’exemple mais bon ça fonctionne. Voilà l’appart du prochain millionaire : 23, Avenue Pierre 1er de Serbie, Quartier de Chaillot, Paris 16e Arrondissement\nà côté de la tour eiffel sympa."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "à propos",
    "section": "",
    "text": "Probablement le meilleur blog de tous les temps."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "my_blog",
    "section": "",
    "text": "Retrouver tous mes posts juste en dessous !\n\n\n\n\n\n\n\n\n  \n\n\n\n\nUtilisation Package olympicsWeather\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nMar 3, 2024\n\n\nSimon Dupas-Brousse\n\n\n\n\n\n\n  \n\n\n\n\nExercice 3\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nMar 2, 2024\n\n\nSimon Dupas-Brousse\n\n\n\n\n\n\n  \n\n\n\n\nExercice 2\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nMar 1, 2024\n\n\nSimon Dupas-Brousse\n\n\n\n\n\n\n  \n\n\n\n\nExercice 1\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nFeb 27, 2024\n\n\nSimon Dupas-Brousse\n\n\n\n\n\n\n  \n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nFeb 25, 2024\n\n\nSimon Dupas-Brousse\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/exercice_2/index.html",
    "href": "posts/exercice_2/index.html",
    "title": "Exercice 2",
    "section": "",
    "text": "Je préviens tout de suite que je n’ai pas continué au-delà de la question 6. Honnêtement, c’est beaucoup trop dur avec le peu d’entraînement qu’on a. J’ai préféré investir mon temps sur GitHub :)\n\nlibrary(rvest)\nlibrary(purrr)\n\n\nLancez la commande suivante :\n\n\nlist_tables &lt;-\nsession(\"https://fr.wikipedia.org/wiki/Liste_des_m%C3%A9daill%C3%A9s_olympiques\") |&gt;\nhtml_elements(\".wikitable\") |&gt;\nhtml_table()\n\nOn a charger des tables sous forme de listes\n\nNous allons tout d’abord nous intéresser à la première table. Créez un objet intitulé data_medailles_sport_ete contenant le premier élément de list_tables. La table n’est pas bien formattée. Supprimez la première colonne, les noms de colonnes et la première ligne. Renommez les colonnes en c(“Discipline”, “Annees”, “Editions”, “Epreuves_2020”, “Or”, “Argent”, “Bronze”, “Total”, “Athletes_medailles”, “Athletes_or”). Les colonnes Editions, Epreuves_2020, Or, Argent, Bronze, Total seront converties en colonnes d’entiers.\n\n\n# Créez un objet intitulé data_medailles_sport_ete contenant le premier élément de list_tables. \ndata_medailles_sport_ete &lt;- list_tables[[1]]\n\n# Supprimer la première colonne et ligne\ndata_medailles_sport_ete &lt;- data_medailles_sport_ete[-1, -1,]\n\n# Renommer les colonnes (list noms)\nnouveaux_noms &lt;- c(\"Discipline\", \"Annees\", \"Editions\", \"Epreuves_2020\", \n                   \"Or\", \"Argent\", \"Bronze\", \"Total\", \"Athletes_medailles\", \n                   \"Athletes_or\")\n\n# Renommer les colonnes\ncolnames(data_medailles_sport_ete) &lt;- nouveaux_noms\n\n# Convertion en entier\nlibrary(dplyr)\n\n\nAttachement du package : 'dplyr'\n\n\nLes objets suivants sont masqués depuis 'package:stats':\n\n    filter, lag\n\n\nLes objets suivants sont masqués depuis 'package:base':\n\n    intersect, setdiff, setequal, union\n\ncols_to_convert &lt;- c(\"Editions\", \"Epreuves_2020\", \"Or\", \"Argent\", \"Bronze\", \"Total\")\n\ndata_medailles_sport_ete &lt;- mutate_at(data_medailles_sport_ete, vars(cols_to_convert), as.integer)\n\nWarning: Using an external vector in selections was deprecated in tidyselect 1.1.0.\nℹ Please use `all_of()` or `any_of()` instead.\n  # Was:\n  data %&gt;% select(cols_to_convert)\n\n  # Now:\n  data %&gt;% select(all_of(cols_to_convert))\n\nSee &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;.\n\nsummary(data_medailles_sport_ete)\n\n  Discipline           Annees             Editions     Epreuves_2020  \n Length:30          Length:30          Min.   : 4.00   Min.   : 2.00  \n Class :character   Class :character   1st Qu.:14.25   1st Qu.: 2.25  \n Mode  :character   Mode  :character   Median :25.50   Median : 7.00  \n                                       Mean   :20.70   Mean   :10.57  \n                                       3rd Qu.:27.00   3rd Qu.:14.75  \n                                       Max.   :29.00   Max.   :48.00  \n       Or              Argent            Bronze            Total       \n Min.   :   8.00   Min.   :   8.00   Min.   :   9.00   Min.   :  19.0  \n 1st Qu.:  34.25   1st Qu.:  34.25   1st Qu.:  35.25   1st Qu.: 103.8  \n Median : 100.50   Median : 101.00   Median : 109.50   Median : 311.0  \n Mean   : 179.53   Mean   : 178.10   Mean   : 194.17   Mean   : 551.6  \n 3rd Qu.: 257.75   3rd Qu.: 256.00   3rd Qu.: 269.75   3rd Qu.: 769.5  \n Max.   :1028.00   Max.   :1030.00   Max.   :1027.00   Max.   :3085.0  \n Athletes_medailles Athletes_or       \n Length:30          Length:30         \n Class :character   Class :character  \n Mode  :character   Mode  :character  \n                                      \n                                      \n                                      \n\n\n\nQuelles sont les 3 disciplines avec le plus de médailles distribuées depuis le début de l’histoire des jeux olympiques ?\n\n\ndata_medailles_sport_ete %&gt;% \n  arrange(desc(Total)) %&gt;%  # Trie par ordre décroissant de la colonne \"Total\"\n  head(3)\n\n# A tibble: 3 × 10\n  Discipline             Annees Editions Epreuves_2020    Or Argent Bronze Total\n  &lt;chr&gt;                  &lt;chr&gt;     &lt;int&gt;         &lt;int&gt; &lt;int&gt;  &lt;int&gt;  &lt;int&gt; &lt;int&gt;\n1 Athlétisme             Depui…       29            48  1028   1030   1027  3085\n2 Natation(hommes, femm… Depui…       29            37   607    604    603  1814\n3 Lutte                  1896,…       28            18   430    429    499  1358\n# ℹ 2 more variables: Athletes_medailles &lt;chr&gt;, Athletes_or &lt;chr&gt;\n\n\n\nQuelles sont les 3 disciplines avec le moins d’épreuves en 2020 ?\n\n\ndata_medailles_sport_ete %&gt;% \n  arrange(Epreuves_2020) %&gt;%\n  head(10)\n\n# A tibble: 10 × 10\n   Discipline            Annees Editions Epreuves_2020    Or Argent Bronze Total\n   &lt;chr&gt;                 &lt;chr&gt;     &lt;int&gt;         &lt;int&gt; &lt;int&gt;  &lt;int&gt;  &lt;int&gt; &lt;int&gt;\n 1 Football              1900–…       27             2    34     34     35   103\n 2 Golf                  1900–…        4             2     8      8      9    19\n 3 Handball              1936,…       14             2    26     26     26    78\n 4 Hockey sur gazon      1908,…       24             2    35     35     36   106\n 5 Natation synchronisée Depui…       10             2    20     18     19    57\n 6 Pentathlon moderne    Depui…       25             2    42     42     42   126\n 7 Volley-ball           Depui…       15             2    30     30     30    90\n 8 Water polo            1900,…       26             2    28     28     29    85\n 9 Triathlon             Depui…        6             3    13     13     13    39\n10 Basket-ball           Depui…       20             4    32     32     32    96\n# ℹ 2 more variables: Athletes_medailles &lt;chr&gt;, Athletes_or &lt;chr&gt;\n\n\nIl y en a 8.\n\nLa colonne Editions nous renseigne sur le nombre total d’apparence des disciplines aux JO d’été. Nous souhaitons vérifier ce calcul en implémentant notre propre fonction calcul_nb_editions_int. Dans un premier temps, la fonction calcul_nb_editions prendra en entrée un paramètre depuis, de type entier, qui représente depuis quelle année la discipline est au programme.\n\nSi je comprends bien, on doit faire une fonction qui doit compter le nombre de fois qu’une discipline (une ligne donc) a eu lieu aux JOs en se servant de la colonne Annees.\nd’abord on sépare par des virgules. puis ifelse pour gérer les 3 situations possibles et extraire les dates. ensuite setdiff\n\nlibrary(stringr)\n\nWarning: le package 'stringr' a été compilé avec la version R 4.3.2\n\nx= \"1896, 1900,1908–1924,depuis 1932\"\nr = str_split(x,\",\", simplify = TRUE)\n\nr[1, 1]\n\n[1] \"1896\"\n\nas.integer(r[1, 2])\n\n[1] 1900\n\n# le + permet d'extraire les chiffres qui sont ensembles\nstr_extract_all(r[1, 3],\"\\\\d+\")\n\n[[1]]\n[1] \"1908\" \"1924\"\n\n# on peut aussi faire ça :\na = sapply(str_split(r[1, 3],\"-\"), as.integer)\n\nWarning in lapply(X = X, FUN = FUN, ...): NAs introduits lors de la conversion\nautomatique\n\n#seq(a[1], a[2], 4)\n#seq(1896, 1896, 4)\n#setdiff()\n\nPour me simplifier la tâche, j’extraie la première occurrence de quatre chiffres dans Annee :\n\nannee_apparition = regmatches(data_medailles_sport_ete$Annees, regexpr(\"\\\\b\\\\d{4}\\\\b\", data_medailles_sport_ete$Annees))\nannee_apparition\n\n [1] \"1896\" \"1900\" \"1992\" \"1936\" \"1904\" \"1936\" \"1896\" \"1900\" \"1896\" \"1900\"\n[11] \"1900\" \"1896\" \"1936\" \"1896\" \"1908\" \"1964\" \"1896\" \"1896\" \"1984\" \"1912\"\n[21] \"1904\" \"2000\" \"1896\" \"1988\" \"1896\" \"1900\" \"2000\" \"1900\" \"1964\" \"1900\"\n\n\nEnsuite on peut faire la fonction :\n\ncalcul_nb_editions &lt;- function(depuis) {\n  \n  nb_editions &lt;- numeric(length(annee_apparition))\n  # pour etre sur que c'est un num\n  depuis &lt;- as.numeric(depuis)\n  \n  # Pour chaque discipline\n  for (i in seq_along(annee_apparition)) {\n    # Récupère l'année d'apparition de la discipline\n    annee &lt;- as.numeric(annee_apparition[[i]])\n    \n    # Si 'depuis' est supérieur ou égal à l'année d'apparition\n    if (depuis &gt;= annee) {\n      nb_editions[i] &lt;- (2020 - depuis) / 4 + 1\n    } else {\n      nb_editions[i] &lt;- (2020 - annee) / 4 + 1\n    }\n  }\n  return(nb_editions)\n}\n\ncalcul_nb_editions(1800)\n\n [1] 32 31  8 22 30 22 32 31 32 31 31 32 22 32 29 15 32 32 10 28 30  6 32  9 32\n[26] 31  6 31 15 31\n\n\nElle fonctionne à quelques détails près comme le fait qu’il y a eu des interruptions. (oui du coup elle ne fonctionne pas vraiment :/ )"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Utilisation Package olympicsWeather",
    "section": "",
    "text": "Ce package permet d’obtenir les prévisions météorologiques horaires pour les sept jours à venir du lieu choisi par l’utilisateur grâce à sa fonction “get_forecast”.\nComment l’installer ?\nSi ce n’est pas déjà fait, installer le package remotes en rentrant dans la console :\n\ninstall.packages(\"remotes\")\n\nEnsuite il faut utiliser cette commande dans la console :\n\nremotes::install_github(\"simdups/olympicsWeather\")\n\nEt voilà ! Il ne reste plus qu’à utiliser la fonction “get_forecast” pour le lieu de votre choix :\n\nlibrary(olympicsWeather)\nmétéo_nantes = get_forecast(\"Nantes\")\n\nVous devriez obtenir une table comme celle-ci :"
  },
  {
    "objectID": "posts/post-with-code/index.html#librairie-olympicsweather",
    "href": "posts/post-with-code/index.html#librairie-olympicsweather",
    "title": "Utilisation Package olympicsWeather",
    "section": "",
    "text": "Ce package permet d’obtenir les prévisions météorologiques horaires pour les sept jours à venir du lieu choisi par l’utilisateur grâce à sa fonction “get_forecast”.\nComment l’installer ?\nSi ce n’est pas déjà fait, installer le package remotes en rentrant dans la console :\n\ninstall.packages(\"remotes\")\n\nEnsuite il faut utiliser cette commande dans la console :\n\nremotes::install_github(\"simdups/olympicsWeather\")\n\nEt voilà ! Il ne reste plus qu’à utiliser la fonction “get_forecast” pour le lieu de votre choix :\n\nlibrary(olympicsWeather)\nmétéo_nantes = get_forecast(\"Nantes\")\n\nVous devriez obtenir une table comme celle-ci :"
  },
  {
    "objectID": "posts/post-with-code/index.html#exemples-dutilisation",
    "href": "posts/post-with-code/index.html#exemples-dutilisation",
    "title": "Utilisation Package olympicsWeather",
    "section": "Exemples d’utilisation",
    "text": "Exemples d’utilisation\n\nStade de France\n\nget_forecast(\"stade de France\")\n\n\n\nTahiti\n\nget_forecast(\"Tahiti\")\n\n\n\nDes coordonnées : 43.276703, 5.334791\nPour cet exemple, les coordonnées doivent être transformées en vecteur au préalable.\n\nSoit en créant un objet (ici je crée “coord”) :\n\n\ncoord = c(43.276703, 5.334791)\nget_forecast(coord)\n\n\nSoit en rentrant directement le contenu de l’objet en argument :\n\n\nget_forecast(c(43.276703, 5.334791))"
  }
]