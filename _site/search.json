[
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "Bienvenue sur mon blog ! Ici, je partage mes réflexions et mes expériences sur divers sujets. Je publie régulièrement (c’est faux) des articles sur la météo (encore un mensonge), et j’espère que vous trouverez mes billets intéressants et utiles. N’hésitez pas à laisser des commentaires et à partager vos propres expériences. Je suis toujours ravi de discuter avec mes (nombreux) lecteurs !"
  },
  {
    "objectID": "posts/exercice_3/index.html",
    "href": "posts/exercice_3/index.html",
    "title": "Exercice 3",
    "section": "",
    "text": "Listez les fichiers présents dans le dossier data. Quelles sont les extensions des différents fichiers ?\n\n\nlist.files(\"data/\")\n\n.sqlite .json .parquet\n\nLisez le fichier .parquet en utilisant la librairie arrow. Quelles sont les dimensions de la table ? Quelles sont les colonnes présentes ?\n\n\nlibrary(arrow)\ntokyo = read_parquet(\"data/tokyo_athletes.parquet\")\nstr(tokyo)\n\n\nLisez le fichier .json en utilisant la librairie jsonlite. Quelles sont les dimensions de la table ? Quelles sont les colonnes présentes ?\n\n\nlibrary(jsonlite)\nolympics = read_json(\"data/olympics_athletes.json\")\nlength(olympics)\n\nC’est une liste qui contient 269731 listes. Comme le montre cet exemple :\n\nolympics[1]\n\nChaque liste contient des données propres à un athlète. Donc on a des infos (ID, nom, …) sur 269731 athlètes.\nOn va le convertir en df pour la suite :\n\nolymp = fromJSON(\"data/olympics_athletes.json\")\nstr(olymp)\n\n\nImportez la librairie RSQLite, et ouvrez une connexion à la base de données sqlite en utilisant la fonction dbConnect. Le driver à utiliser sera SQLite(). Quelles sont les tables présentes dans la table ? Vous pourrez utiliser la fonction dbListTables.\n\n\nlibrary(RSQLite)\ncon &lt;- dbConnect(SQLite(), dbname = \"data/data.sqlite\")\ndbListTables(con)\n\n\nCréez deux nouvelles tables dans la base de données à l’aide de la fonction dbWriteTable. Les tables s’appeleront respectivement olympics_athletes et tokyo_athletes pour les fichiers olympics_athletes.json et tokyo_athletes.parquet.\n\nJe me suis rendu compte que dbWriteTable ne prend que des data.frame en “value”. Donc j’ai fait quelques transformations de class pour pouvoir insérer les 2 tables (je l’ai déjà fait plus haut pour le JSON).\n\ntokyo_df &lt;- as.data.frame(tokyo)\nstr(tokyo_df)\n\ndbWriteTable(con,\"tokyo_athletes\", tokyo_df)\ndbWriteTable(con,\"olympics_athletes\", olymp)\n\n\nInspectez la table olympics_athletes en utilisant la fonction dbListFields. Quelles sont les colonnes de la table ?\n\n\ndbListFields(con,\"olympics_athletes\")\n\n\nImportez cette table depuis la base de données en utilisant la fonction dbReadTable. Convertissez la table en tibble en utilisant la fonction as_tibble.\n\n\nlibrary(tibble)\nolympiii = dbReadTable(con,\"olympics_athletes\")\nolympiii_tibble = as_tibble(olympiii)\nclass(olympiii_tibble)\n\n\nConvertissez la colonne Sex en variable catégorielle avec la fonction mutate.\n\n\nlibrary(dplyr)\nlibrary(tidyr)\n\nolympiii_tibble = olympiii_tibble %&gt;%\n  mutate(Sex = factor(Sex))\n\nclass(olympiii_tibble$Sex)\n\n\nCréez deux colonnes à partir de la colonne Games. La première colonne Year sera une colonne de type integer contenant l’année des jeux. La deuxième colonne isSummer sera une colonne booléenne qui indiquera si les jeux sont des jeux d’été ou d’hiver. Vous pourrez utiliser la fonction separate_wider_delim de tidyr notamment. Les questions suivantes nécessitent l’application de plusieurs instructions en séquence. Essayez tant que possible de chaîner les instructions avec des pipes (%&gt;% ou |&gt;).\n\n\nolympiii_tibble &lt;- olympiii_tibble |&gt;\n  separate_wider_delim(Games,\n    names = c(\"Year\", \"isSummer\"),\n    delim = \" \"\n  ) |&gt;\n  mutate(\n    Year = as.integer(Year),\n    isSummer = if_else(isSummer == \"Summer\", TRUE, FALSE)\n  )\n\nstr(olympiii_tibble)\n\n\nCalculez la moyenne d’age des athletes pour chacune des éditions des JO d’été. Quelle édition a compté les athlètes les plus jeunes ? Les plus vieux ?\n\nPour les plus jeunes :\n\nmean_age_by_year &lt;- olympiii_tibble |&gt;\n  group_by(Year) |&gt; \n  summarize(mean_age = mean(Age, na.rm = TRUE)) |&gt; \n  arrange(mean_age)\nhead(mean_age_by_year,1)\n\nPour les plus vieux :\n\nmean_age_by_year |&gt; \n  arrange(desc(mean_age)) |&gt; \n  head(1)\n\n\nQuelle est la discipline des JO d’été dont la taille des athlètes féminines est la plus grande ?\n\n\nfemale_athletes &lt;- olympiii_tibble %&gt;%\n  filter(Sex == \"F\",isSummer == TRUE) |&gt; \n  arrange(desc(Height))\n\nhead(female_athletes$Sport,1)\n\nQuelle a été cette discipline au cours de chacune des éditions ?\n\nlargest_height_by_year &lt;- female_athletes %&gt;%\n  group_by(Year) %&gt;%\n  top_n(1, Height) %&gt;%\n  select(Year, Sport, Height, Name)\nlargest_height_by_year\n\nCalculez le nombre de fois où chaque discipline a été la discipline avec les plus grandes athlètes.\n\nlargest_height_by_year %&gt;%\n  count(Sport)\n\nVous disposez du texte suivant :\n\ntexte = \"Les jeux olympiques d’été se déroulent normalement tous les 4 ans, durant les mois de Juillet et Août. Les jeux de Rio ont eu lieu du 5 Août 2016 au 20 Août 2016,\nceux de Tokyo du 23 Juillet 2021 au 8 Août 2021, et ceux de Paris auront lieu du\n26 Juillet 2024 au 11 Août 2024. Plus de 10000 athlètes sont attendus du monde\nentier à Paris.\"\n\n\nEn utilisant les fonctions du packages stringr, extrayez les dates des différentes éditions des JO. Aide : définissez une expression régulière capable de capturer une séquence de caractères représentant une date telle que “26 Juillet 2024”. Vous pourrez utiliser cette regex avec la fonction str_extract_all par exemple.\n\n\nlibrary(stringr)\ndate = str_extract_all(texte, \"\\\\b\\\\d{1,2}\\\\s(?:Janvier|Février|Mars|Avril|Mai|Juin|Juillet|Août|Septembre|Octobre|Novembre|Décembre)\\\\s\\\\d{4}\\\\b\")\ndate\n\n\nRemplacez les noms des mois par leur numéro pour rendre ces éléments convertibles en date en utilisant la fonction str_replace.\n\n\ntexte_avant_date = str_replace_all(date[[1]],\n  c(\"Juillet\" = \"07\", \"Août\" = \"08\")\n)\ntexte_avant_date\n\n\nConvertissez ces 3 éléments en date en utilisant la fonction appropriée du package lubridate.\n\n\nlibrary(lubridate)\ntexte_modifie &lt;- gsub(\"\\\\b(\\\\d{1,2}) (\\\\d{2}) (\\\\d{4})\\\\b\", \"\\\\1-\\\\2-\\\\3\", texte_avant_date)\ndate_final = dmy(texte_modifie)\nclass(date_final)\n\n\nCombien de jours ont séparés les éditions de Rio et Tokyo ? Et sépareront les éditions de Tokyo et de Paris ? Faites le même calcul en semaines.\n\n\nRio_Tokyo = interval(start = \"2016-08-20\", end = \"2021-07-23\")\nas.numeric(Rio_Tokyo, \"days\")\nas.numeric(Rio_Tokyo, \"week\")\n\n\nTokyo_Paris = interval(start = \"2021-08-08\", end = \"2024-07-26\")\nas.numeric(Tokyo_Paris, \"days\")\nas.numeric(Tokyo_Paris, \"week\")"
  },
  {
    "objectID": "posts/exercice_1/index.html",
    "href": "posts/exercice_1/index.html",
    "title": "Exercice 1",
    "section": "",
    "text": "importation :\n\npath = (\"data/paris-2024-sites-olympiques-et-paralympiques-franciliens.csv\")\ndata_ex = read.table(path, header = TRUE, sep = \";\", quote = \"\\\"\")\n\n\nCréez un script .R intitulé exercice.R.\n\nDésolé mais les quartos c’est mieux. Il faudrait faire ça : usethis::use_r(“exercice”)\n\nLisez le fichier exo_1_ex.txt avec la fonction read.table. Le résultat sera affecté à l’objet de nom data_ex. Le jeux de données contient 4 colonnes. Quels sont les noms et la nature des colonnes ? Combien de lignes contient la data.frame ?\n\n\nstr(data_ex)\n\n31 obs\n\nCombien y a t’il de sites olympiques ?\n\n\nsum(grepl(\"Site olympique\", data_ex$sites_olympiques_paralympiques, ignore.case = TRUE))\n\n26 olympiques\n\nCombien y a t’il de sites paralympiques ?\n\n\nsum(grepl(\"Site paralympique\", data_ex$sites_olympiques_paralympiques, ignore.case = TRUE))\n\n19 paralympiques\n\nQuels sont les sites qui accueillent plusieurs disciplines sportives ?\n\nj’ai juste compté les lignes qui présentent au moins une virgule dans la colonne “sports” :\n\nlibrary(stringr)\nsites_multisports = subset(data_ex, str_count(sports, \",\") &gt; 0)\nsites_multisports$nom\n\n\nQuels sont les disciplines para-olympiques accueillies dans ces sites franciliens ?\n\nDonc parmi les 19 sites qui accueillent plusieurs disciplines, il faut trouver celles qui sont para-olympiques.\nJe suis allé chercher la liste sur https://www.paris2024.org/fr/sports-paralympiques/\nOn obtient ça : Basket fauteuil, boccia, cécifoot, escrime fauteuil goalball, para athlétisme, para aviron, para badminton, para canoë, para cyclisme sur route, para cyclisme sur piste, para équitation (dressage), para haltérophilie, para judo, para natation, para taekwondo, para tennis de table, para tir à l’arc, para tir sportif, para triathlon, rugby fauteuil, tennis fauteuil, volleyball assis\nPour que ça soit plus léger dans le code j’ai utilisé des mots clés tels que para, fauteuil ou assis. Puis j’ai écris les derniers en entier (ceux surlignés).\n\nsites_para_olympiques &lt;- subset(\n  sites_multisports,\n  grepl(\"fauteuil|Para|assis|Goalball|Cécifoot\", sports, ignore.case = TRUE)\n)\n\n\nQuel(s) site(s) accueille(nt) le plus de disciplines différentes ?\n\nComme dans chaque site les disciplines sont tout le temps différentes, on peut se contenter de compter le(s) site(s) avec le plus de virgules. (ou alors j’ai mal compris la question)\n\nnb_disciplines &lt;- str_count(data_ex$sports, \",\")\n\n# nombre de virgule maximum dans un site\nmax_nb_virgules &lt;- max(nb_disciplines)\n\n# tous les sites avec l'indice maximum de virgules\nindices_max &lt;- which(nb_disciplines == max_nb_virgules)\n\n# affichage de leur nom\ndata_ex$nom[indices_max]\n\n\nQuelle discipline aura lieu sur le plus grand nombre de sites ? Quels sont ces sites ?\n\nDans un premier temps, il faut découper correctement les disciplines pour ensuite les compter :\n\nsports_separes &lt;- unlist(strsplit(data_ex$sports, \",\"))\ncomptage_disciplines &lt;- table(sports_separes)\n\nMaintenant, on peut identifier la ou les discipline(s) apparue(s) un maximum :\n\nindices2_max &lt;- which(comptage_disciplines == max(comptage_disciplines))\nnames(comptage_disciplines[indices2_max])\n\nPour finir, on affiche les noms des sites qui présentent la discipline “Athlétisme” :\n\nsites_athletisme &lt;- grep(\"Athlétisme\", data_ex$sports)\ndata_ex$nom[sites_athletisme]\n\n\nA vol d’oiseau, quels sont les sites les deux sites les plus proches ?\n\nDans un premier temps, il faut que les coordonnées soient fournies sous forme de vecteur numérique avec deux éléments (la latitude et la longitude) pour que distHaversine fonctionne. Petit exemple avec les 2 premières lignes du dataset :\n\nlibrary(geosphere)\n\nexemple = data_ex$geo_point[[1]]\nex2 = data_ex$geo_point[[2]]\n\nla = as.numeric(unlist(strsplit(exemple, \",\")))\nla2 = as.numeric(unlist(strsplit(ex2, \",\")))\n\ndistHaversine(la, la2)\n\nOn va se faire une petite fonction qui fait ça pour nous quand on rentre juste data_ex$geo_point[[1]] (par exemple) en paramètre :\n\ndistance_entre_points &lt;- function(coord1, coord2) {\n  coord1 &lt;- as.numeric(strsplit(coord1, \",\")[[1]])\n  coord2 &lt;- as.numeric(strsplit(coord2, \",\")[[1]])\n  distHaversine(coord1, coord2)\n}\n# exemple d'utilisation :\ndistance_entre_points(data_ex$geo_point[[3]],data_ex$geo_point[[4]])\n\nMaintenant l’idée c’est de calculer automatiquement le distance entre tous les sites du dataset à l’aide d’une boucle. On stocke les résultats de cette boucle dans une matrice “distances” :\n\ndistances &lt;- matrix(NA, nrow = nrow(data_ex), ncol = nrow(data_ex))\nfor (i in 1:nrow(data_ex)) {\n  for (j in 1:nrow(data_ex)) {\n    distances[i, j] &lt;- distance_entre_points(data_ex[i, \"geo_point\"], data_ex[j, \"geo_point\"])\n  }\n}\n\n# On fait juste gaffe à virer les distances d'un site à lui même\ndiag(distances) &lt;- NA\n\nMaintenant on peut répondre à la question :\n\ndist_min &lt;- which(distances == min(distances, na.rm = TRUE), arr.ind = TRUE)\n\ndata_ex$nom[dist_min[,1]]\n\nbonus si on veut savoir la distance :\n\n# on cherche la ligne des 2 sites :\nwhich(data_ex$nom == \"Stade BMX de Saint-Quentin-en-Yvelines\")\nwhich(data_ex$nom == \"Vélodrome National de Saint-Quentin-en-Yvelines\")\n\n# on utilise notre fonction :\ndistance_entre_points(data_ex$geo_point[[20]],data_ex$geo_point[[4]])\n\n\nQuels sont les deux sites les plus éloignés ?\n\nPlus qu’à faire l’inverse d’avant :\n\ndist_max &lt;- which(distances == max(distances, na.rm = TRUE), arr.ind = TRUE)\n\ndata_ex$nom[dist_max[,1]]\n\nbonus si on veut savoir la distance :\n\n# on cherche la ligne des 2 sites :\nwhich(data_ex$nom == \"Colline d'Elancourt\")\nwhich(data_ex$nom == \"Stade nautique\")\n\n# on utilise notre fonction :\ndistance_entre_points(data_ex$geo_point[[28]],data_ex$geo_point[[17]])\n\n\nVous êtes un heureux millionaire et souhaitez investir dans un bien immobilier. Vous décidez d’acheter un appartement situé au barycentre de l’ensemble des sites olympiques. Où se situe cet appartement ?\n\nComment calculer un barycentre pour les nuls (pour moi en somme) :\nEn pratique, cela signifie que nous additionnons toutes les latitudes et toutes les longitudes de tous les sites, puis nous divisons par le nombre total de sites pour trouver les coordonnées moyennes, qui représentent le barycentre de tous les sites.\nok ça part :\n\n# on fait une matrice avec les coord exploitables\ncoordonnees &lt;- sapply(data_ex$geo_point, function(x) as.numeric(strsplit(x, \",\")[[1]]))\n# puis on fait la moyenne de lat et long de cette matrice :\nc(mean(coordonnees[1, ]), mean(coordonnees[2, ]))\n\nMaintenant on va utiliser reverse_geocode pour identifier le nom d’une adresse à partir d’une localisation :\n\nlibrary(tidygeocoder)\nlibrary(tibble)\nlibrary(dplyr, warn.conflicts = FALSE)\n\ntibble(\n    latitude = c(48.8668),\n    longitude = c(2.29757)\n  ) %&gt;%\n  reverse_geocode(\n    lat = latitude,\n    long = longitude,\n    method = 'osm',\n    full_results = TRUE\n  )%&gt;%\n  select(address)\n\nj’ai clairement copié collé l’exemple mais bon ça fonctionne. Voilà l’appart du prochain millionaire : 23, Avenue Pierre 1er de Serbie, Quartier de Chaillot, Paris 16e Arrondissement\nà côté de la tour eiffel sympa."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "à propos",
    "section": "",
    "text": "Probablement le meilleur blog de tous les temps."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "my_blog",
    "section": "",
    "text": "Retrouver tous mes posts juste en dessous !\n\n\n\n\n\n\n\n\n  \n\n\n\n\nUtilisation Package olympicsWeather\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nMar 3, 2024\n\n\nSimon Dupas-Brousse\n\n\n\n\n\n\n  \n\n\n\n\nExercice 3\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nMar 2, 2024\n\n\nSimon Dupas-Brousse\n\n\n\n\n\n\n  \n\n\n\n\nExercice 2\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nMar 1, 2024\n\n\nSimon Dupas-Brousse\n\n\n\n\n\n\n  \n\n\n\n\nExercice 1\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nFeb 27, 2024\n\n\nSimon Dupas-Brousse\n\n\n\n\n\n\n  \n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nFeb 25, 2024\n\n\nSimon Dupas-Brousse\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/exercice_2/index.html",
    "href": "posts/exercice_2/index.html",
    "title": "Exercice 2",
    "section": "",
    "text": "Je préviens tout de suite que je n’ai pas continué au-delà de la question 6. Honnêtement, c’est beaucoup trop dur avec le peu d’entraînement qu’on a. J’ai préféré investir mon temps sur GitHub :)\n\nlibrary(rvest)\nlibrary(purrr)\n\n\nLancez la commande suivante :\n\n\nlist_tables &lt;-\nsession(\"https://fr.wikipedia.org/wiki/Liste_des_m%C3%A9daill%C3%A9s_olympiques\") |&gt;\nhtml_elements(\".wikitable\") |&gt;\nhtml_table()\n\nOn a charger des tables sous forme de listes\n\nNous allons tout d’abord nous intéresser à la première table. Créez un objet intitulé data_medailles_sport_ete contenant le premier élément de list_tables. La table n’est pas bien formattée. Supprimez la première colonne, les noms de colonnes et la première ligne. Renommez les colonnes en c(“Discipline”, “Annees”, “Editions”, “Epreuves_2020”, “Or”, “Argent”, “Bronze”, “Total”, “Athletes_medailles”, “Athletes_or”). Les colonnes Editions, Epreuves_2020, Or, Argent, Bronze, Total seront converties en colonnes d’entiers.\n\n\n# Créez un objet intitulé data_medailles_sport_ete contenant le premier élément de list_tables. \ndata_medailles_sport_ete &lt;- list_tables[[1]]\n\n# Supprimer la première colonne et ligne\ndata_medailles_sport_ete &lt;- data_medailles_sport_ete[-1, -1,]\n\n# Renommer les colonnes (list noms)\nnouveaux_noms &lt;- c(\"Discipline\", \"Annees\", \"Editions\", \"Epreuves_2020\", \n                   \"Or\", \"Argent\", \"Bronze\", \"Total\", \"Athletes_medailles\", \n                   \"Athletes_or\")\n\n# Renommer les colonnes\ncolnames(data_medailles_sport_ete) &lt;- nouveaux_noms\n\n# Convertion en entier\nlibrary(dplyr)\n\ncols_to_convert &lt;- c(\"Editions\", \"Epreuves_2020\", \"Or\", \"Argent\", \"Bronze\", \"Total\")\n\ndata_medailles_sport_ete &lt;- mutate_at(data_medailles_sport_ete, vars(cols_to_convert), as.integer)\n\nsummary(data_medailles_sport_ete)\n\n\nQuelles sont les 3 disciplines avec le plus de médailles distribuées depuis le début de l’histoire des jeux olympiques ?\n\n\ndata_medailles_sport_ete %&gt;% \n  arrange(desc(Total)) %&gt;%  # Trie par ordre décroissant de la colonne \"Total\"\n  head(3)\n\n\nQuelles sont les 3 disciplines avec le moins d’épreuves en 2020 ?\n\n\ndata_medailles_sport_ete %&gt;% \n  arrange(Epreuves_2020) %&gt;%\n  head(10)\n\nIl y en a 8.\n\nLa colonne Editions nous renseigne sur le nombre total d’apparence des disciplines aux JO d’été. Nous souhaitons vérifier ce calcul en implémentant notre propre fonction calcul_nb_editions_int. Dans un premier temps, la fonction calcul_nb_editions prendra en entrée un paramètre depuis, de type entier, qui représente depuis quelle année la discipline est au programme.\n\nSi je comprends bien, on doit faire une fonction qui doit compter le nombre de fois qu’une discipline (une ligne donc) a eu lieu aux JOs en se servant de la colonne Annees.\nd’abord on sépare par des virgules. puis ifelse pour gérer les 3 situations possibles et extraire les dates. ensuite setdiff\n\nlibrary(stringr)\nx= \"1896, 1900,1908–1924,depuis 1932\"\nr = str_split(x,\",\", simplify = TRUE)\n\nr[1, 1]\n\nas.integer(r[1, 2])\n\n\n# le + permet d'extraire les chiffres qui sont ensembles\nstr_extract_all(r[1, 3],\"\\\\d+\")\n# on peut aussi faire ça :\na = sapply(str_split(r[1, 3],\"-\"), as.integer)\n\nseq(a[1], a[2], 4)\nseq(1896, 1896, 4)\nsetdiff()\n\nPour me simplifier la tâche, j’extraie la première occurrence de quatre chiffres dans Annee :\n\nannee_apparition = regmatches(data_medailles_sport_ete$Annees, regexpr(\"\\\\b\\\\d{4}\\\\b\", data_medailles_sport_ete$Annees))\nannee_apparition\n\nEnsuite on peut faire la fonction :\n\ncalcul_nb_editions &lt;- function(depuis) {\n  \n  nb_editions &lt;- numeric(length(annee_apparition))\n  # pour etre sur que c'est un num\n  depuis &lt;- as.numeric(depuis)\n  \n  # Pour chaque discipline\n  for (i in seq_along(annee_apparition)) {\n    # Récupère l'année d'apparition de la discipline\n    annee &lt;- as.numeric(annee_apparition[[i]])\n    \n    # Si 'depuis' est supérieur ou égal à l'année d'apparition\n    if (depuis &gt;= annee) {\n      nb_editions[i] &lt;- (2020 - depuis) / 4 + 1\n    } else {\n      nb_editions[i] &lt;- (2020 - annee) / 4 + 1\n    }\n  }\n  return(nb_editions)\n}\n\ncalcul_nb_editions(1800)\n\nElle fonctionne à quelques détails près comme le fait qu’il y a eu des interruptions. (oui du coup elle ne fonctionne pas vraiment :/ )"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Utilisation Package olympicsWeather",
    "section": "",
    "text": "Ce package permet d’obtenir les prévisions météorologiques horaires pour les sept jours à venir du lieu choisi par l’utilisateur grâce à sa fonction “get_forecast”.\nComment l’installer ?\nSi ce n’est pas déjà fait, installer le package remotes en rentrant dans la console :\n\ninstall.packages(\"remotes\")\n\nEnsuite il faut utiliser cette commande dans la console :\n\nremotes::install_github(\"simdups/olympicsWeather\")\n\nEt voilà ! Il ne reste plus qu’à utiliser la fonction “get_forecast” pour le lieu de votre choix :\n\nlibrary(olympicsWeather)\nmétéo_nantes = get_forecast(\"Nantes\")\n\nVous devriez obtenir une table comme celle-ci :"
  },
  {
    "objectID": "posts/post-with-code/index.html#librairie-olympicsweather",
    "href": "posts/post-with-code/index.html#librairie-olympicsweather",
    "title": "Utilisation Package olympicsWeather",
    "section": "",
    "text": "Ce package permet d’obtenir les prévisions météorologiques horaires pour les sept jours à venir du lieu choisi par l’utilisateur grâce à sa fonction “get_forecast”.\nComment l’installer ?\nSi ce n’est pas déjà fait, installer le package remotes en rentrant dans la console :\n\ninstall.packages(\"remotes\")\n\nEnsuite il faut utiliser cette commande dans la console :\n\nremotes::install_github(\"simdups/olympicsWeather\")\n\nEt voilà ! Il ne reste plus qu’à utiliser la fonction “get_forecast” pour le lieu de votre choix :\n\nlibrary(olympicsWeather)\nmétéo_nantes = get_forecast(\"Nantes\")\n\nVous devriez obtenir une table comme celle-ci :"
  },
  {
    "objectID": "posts/post-with-code/index.html#exemples-dutilisation",
    "href": "posts/post-with-code/index.html#exemples-dutilisation",
    "title": "Utilisation Package olympicsWeather",
    "section": "Exemples d’utilisation",
    "text": "Exemples d’utilisation\n\nStade de France\n\nget_forecast(\"stade de France\")\n\n\n\nTahiti\n\nget_forecast(\"Tahiti\")\n\n\n\nDes coordonnées : 43.276703, 5.334791\nPour cet exemple, les coordonnées doivent être transformées en vecteur au préalable.\n\nSoit en créant un objet (ici je crée “coord”) :\n\n\ncoord = c(43.276703, 5.334791)\nget_forecast(coord)\n\n\nSoit en rentrant directement le contenu de l’objet en argument :\n\n\nget_forecast(c(43.276703, 5.334791))"
  }
]